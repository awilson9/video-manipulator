'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _promise = require('./promise');

var _sanitizePaths = require('./sanitize-paths');

var _sanitizePaths2 = _interopRequireDefault(_sanitizePaths);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const d = require('debug-electron')('electron-compile:file-change-cache');

/**
 * This class caches information about files and determines whether they have
 * changed contents or not. Most importantly, this class caches the hash of seen
 * files so that at development time, we don't have to recalculate them constantly.
 *
 * This class is also the core of how electron-compile runs quickly in production
 * mode - after precompilation, the cache is serialized along with the rest of the
 * data in {@link CompilerHost}, so that when we load the app in production mode,
 * we don't end up calculating hashes of file content at all, only using the contents
 * of this cache.
 */
class FileChangedCache {
  constructor(appRoot) {
    let failOnCacheMiss = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    this.appRoot = (0, _sanitizePaths2.default)(appRoot);

    this.failOnCacheMiss = failOnCacheMiss;
    this.changeCache = {};
  }

  /**
   * Allows you to create a FileChangedCache from serialized data saved from
   * {@link getSavedData}.
   *
   * @param  {Object} data  Saved data from getSavedData.
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   *
   * @return {FileChangedCache}
   */
  static loadFromData(data, appRoot) {
    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    let ret = new FileChangedCache(appRoot, failOnCacheMiss);
    ret.changeCache = data.changeCache;
    ret.originalAppRoot = data.appRoot;

    return ret;
  }

  /**
   * Allows you to create a FileChangedCache from serialized data saved from
   * {@link save}.
   *
   * @param  {string} file  Saved data from save.
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.
   *
   * @return {Promise<FileChangedCache>}
   */
  static loadFromFile(file, appRoot) {
    let failOnCacheMiss = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    return _asyncToGenerator(function* () {
      d(`Loading canned FileChangedCache from ${ file }`);

      let buf = yield _promise.pfs.readFile(file);
      return FileChangedCache.loadFromData(JSON.parse((yield _promise.pzlib.gunzip(buf))), appRoot, failOnCacheMiss);
    })();
  }

  /**
   * Returns information about a given file, including its hash. This method is
   * the main method for this cache.
   *
   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.
   *
   * @return {Promise<Object>}
   *
   * @property {string} hash  The SHA1 hash of the file
   * @property {boolean} isMinified  True if the file is minified
   * @property {boolean} isInNodeModules  True if the file is in a library directory
   * @property {boolean} hasSourceMap  True if the file has a source map
   * @property {boolean} isFileBinary  True if the file is not a text file
   * @property {Buffer} binaryData (optional)  The buffer that was read if the file
   *                                           was binary and there was a cache miss.
   * @property {string} code (optional)  The string that was read if the file
   *                                     was text and there was a cache miss
   */
  getHashForPath(absoluteFilePath) {
    var _this = this;

    return _asyncToGenerator(function* () {
      let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
      if (_this.appRoot) {
        cacheKey = cacheKey.replace(_this.appRoot, '');
      }

      // NB: We do this because x-require will include an absolute path from the
      // original built app and we need to still grok it
      if (_this.originalAppRoot) {
        cacheKey = cacheKey.replace(_this.originalAppRoot, '');
      }

      let cacheEntry = _this.changeCache[cacheKey];

      if (_this.failOnCacheMiss) {
        if (!cacheEntry) {
          d(`Tried to read file cache entry for ${ absoluteFilePath }`);
          d(`cacheKey: ${ cacheKey }, appRoot: ${ _this.appRoot }, originalAppRoot: ${ _this.originalAppRoot }`);
          throw new Error(`Asked for ${ absoluteFilePath } but it was not precompiled!`);
        }

        return cacheEntry.info;
      }

      let stat = yield _promise.pfs.stat(absoluteFilePath);
      let ctime = stat.ctime.getTime();
      let size = stat.size;
      if (!stat || !stat.isFile()) throw new Error(`Can't stat ${ absoluteFilePath }`);

      if (cacheEntry) {
        if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
          return cacheEntry.info;
        }

        d(`Invalidating cache entry: ${ cacheEntry.ctime } === ${ ctime } && ${ cacheEntry.size } === ${ size }`);
        delete _this.changeCache.cacheEntry;
      }

      var _ref = yield _this.calculateHashForFile(absoluteFilePath);

      let digest = _ref.digest,
          sourceCode = _ref.sourceCode,
          binaryData = _ref.binaryData;


      let info = {
        hash: digest,
        isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
        isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
        hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
        isFileBinary: !!binaryData
      };

      _this.changeCache[cacheKey] = { ctime, size, info };
      d(`Cache entry for ${ cacheKey }: ${ JSON.stringify(_this.changeCache[cacheKey]) }`);

      if (binaryData) {
        return Object.assign({ binaryData }, info);
      } else {
        return Object.assign({ sourceCode }, info);
      }
    })();
  }

  /**
   * Returns data that can passed to {@link loadFromData} to rehydrate this cache.
   *
   * @return {Object}
   */
  getSavedData() {
    return { changeCache: this.changeCache, appRoot: this.appRoot };
  }

  /**
   * Serializes this object's data to a file.
   *
   * @param {string} filePath  The path to save data to.
   *
   * @return {Promise} Completion.
   */
  save(filePath) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      let toSave = _this2.getSavedData();

      let buf = yield _promise.pzlib.gzip(new Buffer(JSON.stringify(toSave)));
      yield _promise.pfs.writeFile(filePath, buf);
    })();
  }

  calculateHashForFile(absoluteFilePath) {
    return _asyncToGenerator(function* () {
      let buf = yield _promise.pfs.readFile(absoluteFilePath);
      let encoding = FileChangedCache.detectFileEncoding(buf);

      if (!encoding) {
        let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
        return { sourceCode: null, digest, binaryData: buf };
      }

      let sourceCode = yield _promise.pfs.readFile(absoluteFilePath, encoding);
      let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

      return { sourceCode, digest, binaryData: null };
    })();
  }

  getHashForPathSync(absoluteFilePath) {
    let cacheKey = (0, _sanitizePaths2.default)(absoluteFilePath);
    if (this.appRoot) {
      cacheKey = cacheKey.replace(this.appRoot, '');
    }

    // NB: We do this because x-require will include an absolute path from the
    // original built app and we need to still grok it
    if (this.originalAppRoot) {
      cacheKey = cacheKey.replace(this.originalAppRoot, '');
    }

    if (this.realAppRoot) {
      cacheKey = cacheKey.replace(this.realAppRoot, '');
    }

    let cacheEntry = this.changeCache[cacheKey];

    if (this.failOnCacheMiss) {
      if (!cacheEntry) {
        d(`Tried to read file cache entry for ${ absoluteFilePath }`);
        d(`cacheKey: ${ cacheKey }, appRoot: ${ this.appRoot }, originalAppRoot: ${ this.originalAppRoot }`);
        throw new Error(`Asked for ${ absoluteFilePath } but it was not precompiled!`);
      }

      return cacheEntry.info;
    }

    let stat = _fs2.default.statSync(absoluteFilePath);
    let ctime = stat.ctime.getTime();
    let size = stat.size;
    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${ absoluteFilePath }`);

    if (cacheEntry) {
      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {
        return cacheEntry.info;
      }

      d(`Invalidating cache entry: ${ cacheEntry.ctime } === ${ ctime } && ${ cacheEntry.size } === ${ size }`);
      delete this.changeCache.cacheEntry;
    }

    var _calculateHashForFile = this.calculateHashForFileSync(absoluteFilePath);

    let digest = _calculateHashForFile.digest,
        sourceCode = _calculateHashForFile.sourceCode,
        binaryData = _calculateHashForFile.binaryData;


    let info = {
      hash: digest,
      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),
      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),
      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),
      isFileBinary: !!binaryData
    };

    this.changeCache[cacheKey] = { ctime, size, info };
    d(`Cache entry for ${ cacheKey }: ${ JSON.stringify(this.changeCache[cacheKey]) }`);

    if (binaryData) {
      return Object.assign({ binaryData }, info);
    } else {
      return Object.assign({ sourceCode }, info);
    }
  }

  saveSync(filePath) {
    let toSave = this.getSavedData();

    let buf = _zlib2.default.gzipSync(new Buffer(JSON.stringify(toSave)));
    _fs2.default.writeFileSync(filePath, buf);
  }

  calculateHashForFileSync(absoluteFilePath) {
    let buf = _fs2.default.readFileSync(absoluteFilePath);
    let encoding = FileChangedCache.detectFileEncoding(buf);

    if (!encoding) {
      let digest = _crypto2.default.createHash('sha1').update(buf).digest('hex');
      return { sourceCode: null, digest, binaryData: buf };
    }

    let sourceCode = _fs2.default.readFileSync(absoluteFilePath, encoding);
    let digest = _crypto2.default.createHash('sha1').update(sourceCode, 'utf8').digest('hex');

    return { sourceCode, digest, binaryData: null };
  }

  /**
   * Determines via some statistics whether a file is likely to be minified.
   *
   * @private
   */
  static contentsAreMinified(source) {
    let length = source.length;
    if (length > 1024) length = 1024;

    let newlineCount = 0;

    // Roll through the characters and determine the average line length
    for (let i = 0; i < source.length; i++) {
      if (source[i] === '\n') newlineCount++;
    }

    // No Newlines? Any file other than a super small one is minified
    if (newlineCount === 0) {
      return length > 80;
    }

    let avgLineLength = length / newlineCount;
    return avgLineLength > 80;
  }

  /**
   * Determines whether a path is in node_modules or the Electron init code
   *
   * @private
   */
  static isInNodeModules(filePath) {
    return !!(filePath.match(/(node_modules|bower_components)[\\\/]/i) || filePath.match(/(atom|electron)\.asar/));
  }

  /**
   * Returns whether a file has an inline source map
   *
   * @private
   */
  static hasSourceMap(sourceCode) {
    const trimmed = sourceCode.trim();
    return trimmed.lastIndexOf('//# sourceMap') > trimmed.lastIndexOf('\n');
  }

  /**
   * Determines the encoding of a file from the two most common encodings by trying
   * to decode it then looking for encoding errors
   *
   * @private
   */
  static detectFileEncoding(buffer) {
    if (buffer.length < 1) return false;
    let buf = buffer.length < 4096 ? buffer : buffer.slice(0, 4096);

    const encodings = ['utf8', 'utf16le'];

    let encoding = encodings.find(x => !FileChangedCache.containsControlCharacters(buf.toString(x)));

    return encoding;
  }

  /**
   * Determines whether a string is likely to be poorly encoded by looking for
   * control characters above a certain threshold
   *
   * @private
   */
  static containsControlCharacters(str) {
    let controlCount = 0;
    let spaceCount = 0;
    let threshold = 2;
    if (str.length > 64) threshold = 4;
    if (str.length > 512) threshold = 8;

    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c === 65536 || c < 8) controlCount++;
      if (c > 14 && c < 32) controlCount++;
      if (c === 32) spaceCount++;

      if (controlCount > threshold) return true;
    }

    if (spaceCount < threshold) return true;

    if (controlCount === 0) return false;
    return controlCount / str.length < 0.02;
  }
}
exports.default = FileChangedCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9maWxlLWNoYW5nZS1jYWNoZS5qcyJdLCJuYW1lcyI6WyJkIiwicmVxdWlyZSIsIkZpbGVDaGFuZ2VkQ2FjaGUiLCJjb25zdHJ1Y3RvciIsImFwcFJvb3QiLCJmYWlsT25DYWNoZU1pc3MiLCJjaGFuZ2VDYWNoZSIsImxvYWRGcm9tRGF0YSIsImRhdGEiLCJyZXQiLCJvcmlnaW5hbEFwcFJvb3QiLCJsb2FkRnJvbUZpbGUiLCJmaWxlIiwiYnVmIiwicmVhZEZpbGUiLCJKU09OIiwicGFyc2UiLCJndW56aXAiLCJnZXRIYXNoRm9yUGF0aCIsImFic29sdXRlRmlsZVBhdGgiLCJjYWNoZUtleSIsInJlcGxhY2UiLCJjYWNoZUVudHJ5IiwiRXJyb3IiLCJpbmZvIiwic3RhdCIsImN0aW1lIiwiZ2V0VGltZSIsInNpemUiLCJpc0ZpbGUiLCJjYWxjdWxhdGVIYXNoRm9yRmlsZSIsImRpZ2VzdCIsInNvdXJjZUNvZGUiLCJiaW5hcnlEYXRhIiwiaGFzaCIsImlzTWluaWZpZWQiLCJjb250ZW50c0FyZU1pbmlmaWVkIiwiaXNJbk5vZGVNb2R1bGVzIiwiaGFzU291cmNlTWFwIiwiaXNGaWxlQmluYXJ5Iiwic3RyaW5naWZ5IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0U2F2ZWREYXRhIiwic2F2ZSIsImZpbGVQYXRoIiwidG9TYXZlIiwiZ3ppcCIsIkJ1ZmZlciIsIndyaXRlRmlsZSIsImVuY29kaW5nIiwiZGV0ZWN0RmlsZUVuY29kaW5nIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsImdldEhhc2hGb3JQYXRoU3luYyIsInJlYWxBcHBSb290Iiwic3RhdFN5bmMiLCJjYWxjdWxhdGVIYXNoRm9yRmlsZVN5bmMiLCJzYXZlU3luYyIsImd6aXBTeW5jIiwid3JpdGVGaWxlU3luYyIsInJlYWRGaWxlU3luYyIsInNvdXJjZSIsImxlbmd0aCIsIm5ld2xpbmVDb3VudCIsImkiLCJhdmdMaW5lTGVuZ3RoIiwibWF0Y2giLCJ0cmltbWVkIiwidHJpbSIsImxhc3RJbmRleE9mIiwiYnVmZmVyIiwic2xpY2UiLCJlbmNvZGluZ3MiLCJmaW5kIiwieCIsImNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMiLCJ0b1N0cmluZyIsInN0ciIsImNvbnRyb2xDb3VudCIsInNwYWNlQ291bnQiLCJ0aHJlc2hvbGQiLCJjIiwiY2hhckNvZGVBdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsTUFBTUEsSUFBSUMsUUFBUSxnQkFBUixFQUEwQixvQ0FBMUIsQ0FBVjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXZSxNQUFNQyxnQkFBTixDQUF1QjtBQUNwQ0MsY0FBWUMsT0FBWixFQUE0QztBQUFBLFFBQXZCQyxlQUF1Qix1RUFBUCxLQUFPOztBQUMxQyxTQUFLRCxPQUFMLEdBQWUsNkJBQWlCQSxPQUFqQixDQUFmOztBQUVBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixFQUFuQjtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7O0FBYUEsU0FBT0MsWUFBUCxDQUFvQkMsSUFBcEIsRUFBMEJKLE9BQTFCLEVBQXlEO0FBQUEsUUFBdEJDLGVBQXNCLHVFQUFOLElBQU07O0FBQ3ZELFFBQUlJLE1BQU0sSUFBSVAsZ0JBQUosQ0FBcUJFLE9BQXJCLEVBQThCQyxlQUE5QixDQUFWO0FBQ0FJLFFBQUlILFdBQUosR0FBa0JFLEtBQUtGLFdBQXZCO0FBQ0FHLFFBQUlDLGVBQUosR0FBc0JGLEtBQUtKLE9BQTNCOztBQUVBLFdBQU9LLEdBQVA7QUFDRDs7QUFHRDs7Ozs7Ozs7Ozs7OztBQWFBLFNBQWFFLFlBQWIsQ0FBMEJDLElBQTFCLEVBQWdDUixPQUFoQyxFQUErRDtBQUFBLFFBQXRCQyxlQUFzQix1RUFBTixJQUFNO0FBQUE7QUFDN0RMLFFBQUcseUNBQXVDWSxJQUFLLEdBQS9DOztBQUVBLFVBQUlDLE1BQU0sTUFBTSxhQUFJQyxRQUFKLENBQWFGLElBQWIsQ0FBaEI7QUFDQSxhQUFPVixpQkFB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ZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcclxuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xyXG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XHJcbmltcG9ydCBzYW5pdGl6ZUZpbGVQYXRoIGZyb20gJy4vc2FuaXRpemUtcGF0aHMnO1xyXG5cclxuY29uc3QgZCA9IHJlcXVpcmUoJ2RlYnVnLWVsZWN0cm9uJykoJ2VsZWN0cm9uLWNvbXBpbGU6ZmlsZS1jaGFuZ2UtY2FjaGUnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNhY2hlcyBpbmZvcm1hdGlvbiBhYm91dCBmaWxlcyBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXkgaGF2ZVxyXG4gKiBjaGFuZ2VkIGNvbnRlbnRzIG9yIG5vdC4gTW9zdCBpbXBvcnRhbnRseSwgdGhpcyBjbGFzcyBjYWNoZXMgdGhlIGhhc2ggb2Ygc2VlblxyXG4gKiBmaWxlcyBzbyB0aGF0IGF0IGRldmVsb3BtZW50IHRpbWUsIHdlIGRvbid0IGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlbSBjb25zdGFudGx5LlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGlzIGFsc28gdGhlIGNvcmUgb2YgaG93IGVsZWN0cm9uLWNvbXBpbGUgcnVucyBxdWlja2x5IGluIHByb2R1Y3Rpb25cclxuICogbW9kZSAtIGFmdGVyIHByZWNvbXBpbGF0aW9uLCB0aGUgY2FjaGUgaXMgc2VyaWFsaXplZCBhbG9uZyB3aXRoIHRoZSByZXN0IG9mIHRoZVxyXG4gKiBkYXRhIGluIHtAbGluayBDb21waWxlckhvc3R9LCBzbyB0aGF0IHdoZW4gd2UgbG9hZCB0aGUgYXBwIGluIHByb2R1Y3Rpb24gbW9kZSxcclxuICogd2UgZG9uJ3QgZW5kIHVwIGNhbGN1bGF0aW5nIGhhc2hlcyBvZiBmaWxlIGNvbnRlbnQgYXQgYWxsLCBvbmx5IHVzaW5nIHRoZSBjb250ZW50c1xyXG4gKiBvZiB0aGlzIGNhY2hlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZUNoYW5nZWRDYWNoZSB7XHJcbiAgY29uc3RydWN0b3IoYXBwUm9vdCwgZmFpbE9uQ2FjaGVNaXNzPWZhbHNlKSB7XHJcbiAgICB0aGlzLmFwcFJvb3QgPSBzYW5pdGl6ZUZpbGVQYXRoKGFwcFJvb3QpO1xyXG5cclxuICAgIHRoaXMuZmFpbE9uQ2FjaGVNaXNzID0gZmFpbE9uQ2FjaGVNaXNzO1xyXG4gICAgdGhpcy5jaGFuZ2VDYWNoZSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3dzIHlvdSB0byBjcmVhdGUgYSBGaWxlQ2hhbmdlZENhY2hlIGZyb20gc2VyaWFsaXplZCBkYXRhIHNhdmVkIGZyb21cclxuICAgKiB7QGxpbmsgZ2V0U2F2ZWREYXRhfS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAgU2F2ZWQgZGF0YSBmcm9tIGdldFNhdmVkRGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZhaWxPbkNhY2hlTWlzcyAob3B0aW9uYWwpICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCB0aHJvdy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0ZpbGVDaGFuZ2VkQ2FjaGV9XHJcbiAgICovXHJcbiAgc3RhdGljIGxvYWRGcm9tRGF0YShkYXRhLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9dHJ1ZSkge1xyXG4gICAgbGV0IHJldCA9IG5ldyBGaWxlQ2hhbmdlZENhY2hlKGFwcFJvb3QsIGZhaWxPbkNhY2hlTWlzcyk7XHJcbiAgICByZXQuY2hhbmdlQ2FjaGUgPSBkYXRhLmNoYW5nZUNhY2hlO1xyXG4gICAgcmV0Lm9yaWdpbmFsQXBwUm9vdCA9IGRhdGEuYXBwUm9vdDtcclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEFsbG93cyB5b3UgdG8gY3JlYXRlIGEgRmlsZUNoYW5nZWRDYWNoZSBmcm9tIHNlcmlhbGl6ZWQgZGF0YSBzYXZlZCBmcm9tXHJcbiAgICoge0BsaW5rIHNhdmV9LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxlICBTYXZlZCBkYXRhIGZyb20gc2F2ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBvbmUgd2hpY2ggaGFzIHlvdXIgcGFja2FnZS5qc29uKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGZhaWxPbkNhY2hlTWlzcyAob3B0aW9uYWwpICBJZiBUcnVlLCBjYWNoZSBtaXNzZXMgd2lsbCB0aHJvdy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8RmlsZUNoYW5nZWRDYWNoZT59XHJcbiAgICovXHJcbiAgc3RhdGljIGFzeW5jIGxvYWRGcm9tRmlsZShmaWxlLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3M9dHJ1ZSkge1xyXG4gICAgZChgTG9hZGluZyBjYW5uZWQgRmlsZUNoYW5nZWRDYWNoZSBmcm9tICR7ZmlsZX1gKTtcclxuXHJcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGUpO1xyXG4gICAgcmV0dXJuIEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKEpTT04ucGFyc2UoYXdhaXQgcHpsaWIuZ3VuemlwKGJ1ZikpLCBhcHBSb290LCBmYWlsT25DYWNoZU1pc3MpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYSBnaXZlbiBmaWxlLCBpbmNsdWRpbmcgaXRzIGhhc2guIFRoaXMgbWV0aG9kIGlzXHJcbiAgICogdGhlIG1haW4gbWV0aG9kIGZvciB0aGlzIGNhY2hlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfSBhYnNvbHV0ZUZpbGVQYXRoICBUaGUgcGF0aCB0byBhIGZpbGUgdG8gcmV0cmlldmUgaW5mbyBvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn1cclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBoYXNoICBUaGUgU0hBMSBoYXNoIG9mIHRoZSBmaWxlXHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc01pbmlmaWVkICBUcnVlIGlmIHRoZSBmaWxlIGlzIG1pbmlmaWVkXHJcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0luTm9kZU1vZHVsZXMgIFRydWUgaWYgdGhlIGZpbGUgaXMgaW4gYSBsaWJyYXJ5IGRpcmVjdG9yeVxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzU291cmNlTWFwICBUcnVlIGlmIHRoZSBmaWxlIGhhcyBhIHNvdXJjZSBtYXBcclxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRmlsZUJpbmFyeSAgVHJ1ZSBpZiB0aGUgZmlsZSBpcyBub3QgYSB0ZXh0IGZpbGVcclxuICAgKiBAcHJvcGVydHkge0J1ZmZlcn0gYmluYXJ5RGF0YSAob3B0aW9uYWwpICBUaGUgYnVmZmVyIHRoYXQgd2FzIHJlYWQgaWYgdGhlIGZpbGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXMgYmluYXJ5IGFuZCB0aGVyZSB3YXMgYSBjYWNoZSBtaXNzLlxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIChvcHRpb25hbCkgIFRoZSBzdHJpbmcgdGhhdCB3YXMgcmVhZCBpZiB0aGUgZmlsZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyB0ZXh0IGFuZCB0aGVyZSB3YXMgYSBjYWNoZSBtaXNzXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0SGFzaEZvclBhdGgoYWJzb2x1dGVGaWxlUGF0aCkge1xyXG4gICAgbGV0IGNhY2hlS2V5ID0gc2FuaXRpemVGaWxlUGF0aChhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGlmICh0aGlzLmFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMuYXBwUm9vdCwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5COiBXZSBkbyB0aGlzIGJlY2F1c2UgeC1yZXF1aXJlIHdpbGwgaW5jbHVkZSBhbiBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlXHJcbiAgICAvLyBvcmlnaW5hbCBidWlsdCBhcHAgYW5kIHdlIG5lZWQgdG8gc3RpbGwgZ3JvayBpdFxyXG4gICAgaWYgKHRoaXMub3JpZ2luYWxBcHBSb290KSB7XHJcbiAgICAgIGNhY2hlS2V5ID0gY2FjaGVLZXkucmVwbGFjZSh0aGlzLm9yaWdpbmFsQXBwUm9vdCwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjYWNoZUVudHJ5ID0gdGhpcy5jaGFuZ2VDYWNoZVtjYWNoZUtleV07XHJcblxyXG4gICAgaWYgKHRoaXMuZmFpbE9uQ2FjaGVNaXNzKSB7XHJcbiAgICAgIGlmICghY2FjaGVFbnRyeSkge1xyXG4gICAgICAgIGQoYFRyaWVkIHRvIHJlYWQgZmlsZSBjYWNoZSBlbnRyeSBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofWApO1xyXG4gICAgICAgIGQoYGNhY2hlS2V5OiAke2NhY2hlS2V5fSwgYXBwUm9vdDogJHt0aGlzLmFwcFJvb3R9LCBvcmlnaW5hbEFwcFJvb3Q6ICR7dGhpcy5vcmlnaW5hbEFwcFJvb3R9YCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCBmb3IgJHthYnNvbHV0ZUZpbGVQYXRofSBidXQgaXQgd2FzIG5vdCBwcmVjb21waWxlZCFgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgIH1cclxuXHJcbiAgICBsZXQgc3RhdCA9IGF3YWl0IHBmcy5zdGF0KGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgbGV0IGN0aW1lID0gc3RhdC5jdGltZS5nZXRUaW1lKCk7XHJcbiAgICBsZXQgc2l6ZSA9IHN0YXQuc2l6ZTtcclxuICAgIGlmICghc3RhdCB8fCAhc3RhdC5pc0ZpbGUoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGF0ICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuXHJcbiAgICBpZiAoY2FjaGVFbnRyeSkge1xyXG4gICAgICBpZiAoY2FjaGVFbnRyeS5jdGltZSA+PSBjdGltZSAmJiBjYWNoZUVudHJ5LnNpemUgPT09IHNpemUpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS5pbmZvO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkKGBJbnZhbGlkYXRpbmcgY2FjaGUgZW50cnk6ICR7Y2FjaGVFbnRyeS5jdGltZX0gPT09ICR7Y3RpbWV9ICYmICR7Y2FjaGVFbnRyeS5zaXplfSA9PT0gJHtzaXplfWApO1xyXG4gICAgICBkZWxldGUgdGhpcy5jaGFuZ2VDYWNoZS5jYWNoZUVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB7ZGlnZXN0LCBzb3VyY2VDb2RlLCBiaW5hcnlEYXRhfSA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlSGFzaEZvckZpbGUoYWJzb2x1dGVGaWxlUGF0aCk7XHJcblxyXG4gICAgbGV0IGluZm8gPSB7XHJcbiAgICAgIGhhc2g6IGRpZ2VzdCxcclxuICAgICAgaXNNaW5pZmllZDogRmlsZUNoYW5nZWRDYWNoZS5jb250ZW50c0FyZU1pbmlmaWVkKHNvdXJjZUNvZGUgfHwgJycpLFxyXG4gICAgICBpc0luTm9kZU1vZHVsZXM6IEZpbGVDaGFuZ2VkQ2FjaGUuaXNJbk5vZGVNb2R1bGVzKGFic29sdXRlRmlsZVBhdGgpLFxyXG4gICAgICBoYXNTb3VyY2VNYXA6IEZpbGVDaGFuZ2VkQ2FjaGUuaGFzU291cmNlTWFwKHNvdXJjZUNvZGUgfHwgJycpLFxyXG4gICAgICBpc0ZpbGVCaW5hcnk6ICEhYmluYXJ5RGF0YVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSA9IHsgY3RpbWUsIHNpemUsIGluZm8gfTtcclxuICAgIGQoYENhY2hlIGVudHJ5IGZvciAke2NhY2hlS2V5fTogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNoYW5nZUNhY2hlW2NhY2hlS2V5XSl9YCk7XHJcblxyXG4gICAgaWYgKGJpbmFyeURhdGEpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe2JpbmFyeURhdGF9LCBpbmZvKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtzb3VyY2VDb2RlfSwgaW5mbyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkYXRhIHRoYXQgY2FuIHBhc3NlZCB0byB7QGxpbmsgbG9hZEZyb21EYXRhfSB0byByZWh5ZHJhdGUgdGhpcyBjYWNoZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBnZXRTYXZlZERhdGEoKSB7XHJcbiAgICByZXR1cm4geyBjaGFuZ2VDYWNoZTogdGhpcy5jaGFuZ2VDYWNoZSwgYXBwUm9vdDogdGhpcy5hcHBSb290IH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIHRoaXMgb2JqZWN0J3MgZGF0YSB0byBhIGZpbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHNhdmUgZGF0YSB0by5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IENvbXBsZXRpb24uXHJcbiAgICovXHJcbiAgYXN5bmMgc2F2ZShmaWxlUGF0aCkge1xyXG4gICAgbGV0IHRvU2F2ZSA9IHRoaXMuZ2V0U2F2ZWREYXRhKCk7XHJcblxyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHB6bGliLmd6aXAobmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeSh0b1NhdmUpKSk7XHJcbiAgICBhd2FpdCBwZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBidWYpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2FsY3VsYXRlSGFzaEZvckZpbGUoYWJzb2x1dGVGaWxlUGF0aCkge1xyXG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZShhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBlbmNvZGluZyA9IEZpbGVDaGFuZ2VkQ2FjaGUuZGV0ZWN0RmlsZUVuY29kaW5nKGJ1Zik7XHJcblxyXG4gICAgaWYgKCFlbmNvZGluZykge1xyXG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1ZiB9O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBzb3VyY2VDb2RlID0gYXdhaXQgcGZzLnJlYWRGaWxlKGFic29sdXRlRmlsZVBhdGgsIGVuY29kaW5nKTtcclxuICAgIGxldCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShzb3VyY2VDb2RlLCAndXRmOCcpLmRpZ2VzdCgnaGV4Jyk7XHJcblxyXG4gICAgcmV0dXJuIHtzb3VyY2VDb2RlLCBkaWdlc3QsIGJpbmFyeURhdGE6IG51bGwgfTtcclxuICB9XHJcblxyXG4gIGdldEhhc2hGb3JQYXRoU3luYyhhYnNvbHV0ZUZpbGVQYXRoKSB7XHJcbiAgICBsZXQgY2FjaGVLZXkgPSBzYW5pdGl6ZUZpbGVQYXRoKGFic29sdXRlRmlsZVBhdGgpO1xyXG4gICAgaWYgKHRoaXMuYXBwUm9vdCkge1xyXG4gICAgICBjYWNoZUtleSA9IGNhY2hlS2V5LnJlcGxhY2UodGhpcy5hcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTkI6IFdlIGRvIHRoaXMgYmVjYXVzZSB4LXJlcXVpcmUgd2lsbCBpbmNsdWRlIGFuIGFic29sdXRlIHBhdGggZnJvbSB0aGVcclxuICAgIC8vIG9yaWdpbmFsIGJ1aWx0IGFwcCBhbmQgd2UgbmVlZCB0byBzdGlsbCBncm9rIGl0XHJcbiAgICBpZiAodGhpcy5vcmlnaW5hbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMub3JpZ2luYWxBcHBSb290LCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucmVhbEFwcFJvb3QpIHtcclxuICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleS5yZXBsYWNlKHRoaXMucmVhbEFwcFJvb3QsICcnKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2FjaGVFbnRyeSA9IHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldO1xyXG5cclxuICAgIGlmICh0aGlzLmZhaWxPbkNhY2hlTWlzcykge1xyXG4gICAgICBpZiAoIWNhY2hlRW50cnkpIHtcclxuICAgICAgICBkKGBUcmllZCB0byByZWFkIGZpbGUgY2FjaGUgZW50cnkgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH1gKTtcclxuICAgICAgICBkKGBjYWNoZUtleTogJHtjYWNoZUtleX0sIGFwcFJvb3Q6ICR7dGhpcy5hcHBSb290fSwgb3JpZ2luYWxBcHBSb290OiAke3RoaXMub3JpZ2luYWxBcHBSb290fWApO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNrZWQgZm9yICR7YWJzb2x1dGVGaWxlUGF0aH0gYnV0IGl0IHdhcyBub3QgcHJlY29tcGlsZWQhYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmluZm87XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHN0YXQgPSBmcy5zdGF0U3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBjdGltZSA9IHN0YXQuY3RpbWUuZ2V0VGltZSgpO1xyXG4gICAgbGV0IHNpemUgPSBzdGF0LnNpemU7XHJcbiAgICBpZiAoIXN0YXQgfHwgIXN0YXQuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3RhdCAke2Fic29sdXRlRmlsZVBhdGh9YCk7XHJcblxyXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcclxuICAgICAgaWYgKGNhY2hlRW50cnkuY3RpbWUgPj0gY3RpbWUgJiYgY2FjaGVFbnRyeS5zaXplID09PSBzaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlRW50cnkuaW5mbztcclxuICAgICAgfVxyXG5cclxuICAgICAgZChgSW52YWxpZGF0aW5nIGNhY2hlIGVudHJ5OiAke2NhY2hlRW50cnkuY3RpbWV9ID09PSAke2N0aW1lfSAmJiAke2NhY2hlRW50cnkuc2l6ZX0gPT09ICR7c2l6ZX1gKTtcclxuICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlQ2FjaGUuY2FjaGVFbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQge2RpZ2VzdCwgc291cmNlQ29kZSwgYmluYXJ5RGF0YX0gPSB0aGlzLmNhbGN1bGF0ZUhhc2hGb3JGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuXHJcbiAgICBsZXQgaW5mbyA9IHtcclxuICAgICAgaGFzaDogZGlnZXN0LFxyXG4gICAgICBpc01pbmlmaWVkOiBGaWxlQ2hhbmdlZENhY2hlLmNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzSW5Ob2RlTW9kdWxlczogRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoYWJzb2x1dGVGaWxlUGF0aCksXHJcbiAgICAgIGhhc1NvdXJjZU1hcDogRmlsZUNoYW5nZWRDYWNoZS5oYXNTb3VyY2VNYXAoc291cmNlQ29kZSB8fCAnJyksXHJcbiAgICAgIGlzRmlsZUJpbmFyeTogISFiaW5hcnlEYXRhXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldID0geyBjdGltZSwgc2l6ZSwgaW5mbyB9O1xyXG4gICAgZChgQ2FjaGUgZW50cnkgZm9yICR7Y2FjaGVLZXl9OiAke0pTT04uc3RyaW5naWZ5KHRoaXMuY2hhbmdlQ2FjaGVbY2FjaGVLZXldKX1gKTtcclxuXHJcbiAgICBpZiAoYmluYXJ5RGF0YSkge1xyXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7YmluYXJ5RGF0YX0sIGluZm8pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe3NvdXJjZUNvZGV9LCBpbmZvKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNhdmVTeW5jKGZpbGVQYXRoKSB7XHJcbiAgICBsZXQgdG9TYXZlID0gdGhpcy5nZXRTYXZlZERhdGEoKTtcclxuXHJcbiAgICBsZXQgYnVmID0gemxpYi5nemlwU3luYyhuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KHRvU2F2ZSkpKTtcclxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGJ1Zik7XHJcbiAgfVxyXG5cclxuICBjYWxjdWxhdGVIYXNoRm9yRmlsZVN5bmMoYWJzb2x1dGVGaWxlUGF0aCkge1xyXG4gICAgbGV0IGJ1ZiA9IGZzLnJlYWRGaWxlU3luYyhhYnNvbHV0ZUZpbGVQYXRoKTtcclxuICAgIGxldCBlbmNvZGluZyA9IEZpbGVDaGFuZ2VkQ2FjaGUuZGV0ZWN0RmlsZUVuY29kaW5nKGJ1Zik7XHJcblxyXG4gICAgaWYgKCFlbmNvZGluZykge1xyXG4gICAgICBsZXQgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnVmKS5kaWdlc3QoJ2hleCcpO1xyXG4gICAgICByZXR1cm4geyBzb3VyY2VDb2RlOiBudWxsLCBkaWdlc3QsIGJpbmFyeURhdGE6IGJ1Zn07XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHNvdXJjZUNvZGUgPSBmcy5yZWFkRmlsZVN5bmMoYWJzb2x1dGVGaWxlUGF0aCwgZW5jb2RpbmcpO1xyXG4gICAgbGV0IGRpZ2VzdCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKHNvdXJjZUNvZGUsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcclxuXHJcbiAgICByZXR1cm4ge3NvdXJjZUNvZGUsIGRpZ2VzdCwgYmluYXJ5RGF0YTogbnVsbH07XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB2aWEgc29tZSBzdGF0aXN0aWNzIHdoZXRoZXIgYSBmaWxlIGlzIGxpa2VseSB0byBiZSBtaW5pZmllZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGNvbnRlbnRzQXJlTWluaWZpZWQoc291cmNlKSB7XHJcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcclxuICAgIGlmIChsZW5ndGggPiAxMDI0KSBsZW5ndGggPSAxMDI0O1xyXG5cclxuICAgIGxldCBuZXdsaW5lQ291bnQgPSAwO1xyXG5cclxuICAgIC8vIFJvbGwgdGhyb3VnaCB0aGUgY2hhcmFjdGVycyBhbmQgZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIGxpbmUgbGVuZ3RoXHJcbiAgICBmb3IobGV0IGk9MDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoc291cmNlW2ldID09PSAnXFxuJykgbmV3bGluZUNvdW50Kys7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gTmV3bGluZXM/IEFueSBmaWxlIG90aGVyIHRoYW4gYSBzdXBlciBzbWFsbCBvbmUgaXMgbWluaWZpZWRcclxuICAgIGlmIChuZXdsaW5lQ291bnQgPT09IDApIHtcclxuICAgICAgcmV0dXJuIChsZW5ndGggPiA4MCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGF2Z0xpbmVMZW5ndGggPSBsZW5ndGggLyBuZXdsaW5lQ291bnQ7XHJcbiAgICByZXR1cm4gKGF2Z0xpbmVMZW5ndGggPiA4MCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcGF0aCBpcyBpbiBub2RlX21vZHVsZXMgb3IgdGhlIEVsZWN0cm9uIGluaXQgY29kZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBzdGF0aWMgaXNJbk5vZGVNb2R1bGVzKGZpbGVQYXRoKSB7XHJcbiAgICByZXR1cm4gISEoZmlsZVBhdGgubWF0Y2goLyhub2RlX21vZHVsZXN8Ym93ZXJfY29tcG9uZW50cylbXFxcXFxcL10vaSkgfHwgZmlsZVBhdGgubWF0Y2goLyhhdG9tfGVsZWN0cm9uKVxcLmFzYXIvKSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgZmlsZSBoYXMgYW4gaW5saW5lIHNvdXJjZSBtYXBcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGhhc1NvdXJjZU1hcChzb3VyY2VDb2RlKSB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gc291cmNlQ29kZS50cmltKCk7XHJcbiAgICByZXR1cm4gdHJpbW1lZC5sYXN0SW5kZXhPZignLy8jIHNvdXJjZU1hcCcpID4gdHJpbW1lZC5sYXN0SW5kZXhPZignXFxuJyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmVzIHRoZSBlbmNvZGluZyBvZiBhIGZpbGUgZnJvbSB0aGUgdHdvIG1vc3QgY29tbW9uIGVuY29kaW5ncyBieSB0cnlpbmdcclxuICAgKiB0byBkZWNvZGUgaXQgdGhlbiBsb29raW5nIGZvciBlbmNvZGluZyBlcnJvcnNcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgc3RhdGljIGRldGVjdEZpbGVFbmNvZGluZyhidWZmZXIpIHtcclxuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgbGV0IGJ1ZiA9IChidWZmZXIubGVuZ3RoIDwgNDA5NiA/IGJ1ZmZlciA6IGJ1ZmZlci5zbGljZSgwLCA0MDk2KSk7XHJcblxyXG4gICAgY29uc3QgZW5jb2RpbmdzID0gWyd1dGY4JywgJ3V0ZjE2bGUnXTtcclxuXHJcbiAgICBsZXQgZW5jb2RpbmcgPSBlbmNvZGluZ3MuZmluZChcclxuICAgICAgKHgpID0+ICFGaWxlQ2hhbmdlZENhY2hlLmNvbnRhaW5zQ29udHJvbENoYXJhY3RlcnMoYnVmLnRvU3RyaW5nKHgpKSk7XHJcblxyXG4gICAgcmV0dXJuIGVuY29kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGlzIGxpa2VseSB0byBiZSBwb29ybHkgZW5jb2RlZCBieSBsb29raW5nIGZvclxyXG4gICAqIGNvbnRyb2wgY2hhcmFjdGVycyBhYm92ZSBhIGNlcnRhaW4gdGhyZXNob2xkXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjb250YWluc0NvbnRyb2xDaGFyYWN0ZXJzKHN0cikge1xyXG4gICAgbGV0IGNvbnRyb2xDb3VudCA9IDA7XHJcbiAgICBsZXQgc3BhY2VDb3VudCA9IDA7XHJcbiAgICBsZXQgdGhyZXNob2xkID0gMjtcclxuICAgIGlmIChzdHIubGVuZ3RoID4gNjQpIHRocmVzaG9sZCA9IDQ7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDUxMikgdGhyZXNob2xkID0gODtcclxuXHJcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgaWYgKGMgPT09IDY1NTM2IHx8IGMgPCA4KSBjb250cm9sQ291bnQrKztcclxuICAgICAgaWYgKGMgPiAxNCAmJiBjIDwgMzIpIGNvbnRyb2xDb3VudCsrO1xyXG4gICAgICBpZiAoYyA9PT0gMzIpIHNwYWNlQ291bnQrKztcclxuXHJcbiAgICAgIGlmIChjb250cm9sQ291bnQgPiB0aHJlc2hvbGQpIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGFjZUNvdW50IDwgdGhyZXNob2xkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29udHJvbENvdW50ID09PSAwKSByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gKGNvbnRyb2xDb3VudCAvIHN0ci5sZW5ndGgpIDwgMC4wMjtcclxuICB9XHJcbn1cclxuIl19